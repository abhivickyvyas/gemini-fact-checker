# Veritas AI

<p align="center">
  <img src="readme/veritas-banner.svg" alt="Veritas AI Banner" width="100%" />
</p>

<h3 align="center">
  <a href="readme/blog-post.md"><strong>ðŸ“– READ THE ENGINEERING DEEP DIVE Â»</strong></a>
</h3>
<p align="center">
  (Architecture, HLD, LLD & Prompt Strategy)
</p>

<br />

Veritas AI is a real-time fact-checking application. It uses the Gemini API with **Google Search Grounding** to verify the factual accuracy of statements, providing a clear verdict, a detailed explanation, and verifiable source links.

## Features

-   **Real-Time Analysis**: Get instant factual analysis of any statement or claim.
-   **Clear Verdicts**: Each check returns a clear, color-coded verdict: **True**, **False**, or **Mixed/Nuanced**.
-   **Detailed Explanations**: Understand the reasoning behind the verdict with a concise explanation generated by Gemini.
-   **Sourced Information**: All claims are backed by a list of sources from Google Search, promoting transparency.
-   **Persistent History**: Past fact-checks are automatically saved to `localStorage` and displayed in a sidebar.
-   **Shareable Results**: Generate high-quality images of your results to share on social media.

## Tech Stack

-   **Frontend**: React 19, TypeScript
-   **Styling**: Tailwind CSS
-   **AI Model**: Google Gemini (`gemini-2.5-flash`)
-   **Core Feature**: Gemini API with Google Search Grounding
-   **Utilities**: `html2canvas` for image generation

## Getting Started

To run this project locally, follow these steps:

1.  **Clone the repository**
    ```bash
    git clone <repository-url>
    cd veritas-ai
    ```

2.  **Install dependencies**
    This project uses a CDN-based import map for React and `@google/genai` (no `npm install` required).

3.  **Set up Environment Variables**
    The application requires a Google Gemini API key.
    ```
    API_KEY=YOUR_GEMINI_API_KEY
    ```

4.  **Run the application**
    Open `index.html` in your browser using a local web server (e.g., VS Code Live Server).

## Project Structure

The project is organized for clarity and separation of concerns.

```
.
â”œâ”€â”€ readme/
â”‚   â”œâ”€â”€ blog-post.md         # ðŸ“– The main engineering documentation
â”‚   â”œâ”€â”€ veritas-banner.svg   # Project banner image
â”‚   â””â”€â”€ post.md              # Social media launch copy
â”œâ”€â”€ services/
â”‚   â””â”€â”€ geminiService.ts     # API communication layer
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ResultCard.tsx       # Verdict display & image generation logic
â”‚   â”œâ”€â”€ History.tsx          # Sidebar history management
â”‚   â””â”€â”€ ...
â”œâ”€â”€ App.tsx                  # Main application controller
â”œâ”€â”€ index.html               # Entry point
â””â”€â”€ types.ts                 # TypeScript interfaces
```

## How It Works

The user enters a claim into the app. The `geminiService` sends this claim to the Gemini API with the `googleSearch` tool enabled.

The model:
1.  Analyzes the claim.
2.  Performs a live Google Search.
3.  Synthesizes the search results.
4.  Returns a structured response (Verdict + Explanation + Sources).

For a detailed breakdown of the architecture, sequence diagrams, and prompt engineering strategy, strictly refer to the **[Engineering Blog Post](readme/blog-post.md)**.